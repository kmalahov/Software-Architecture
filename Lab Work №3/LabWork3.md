### Лабораторная работа 3
# Диаграмма компонентов:
![telegram-cloud-photo-size-2-5467625941019776838-y](https://github.com/kmalahov/Software-Architecture/assets/55401680/113e372f-d291-4ad7-b2d1-fd49e99b4e0c)

# Диаграмма последовательности:
![telegram-cloud-photo-size-2-5467625941019777035-y](https://github.com/kmalahov/Software-Architecture/assets/55401680/49bb5b70-ad68-4969-bf72-05d385977970)

# Модель базы данных
![telegram-cloud-photo-size-2-5467625941019776988-y](https://github.com/kmalahov/Software-Architecture/assets/55401680/dcac490d-8754-40a3-a64c-b49bf3023ed8)


 Краткое пояснение к модели базы данных:

1. **Пользователи (`users`)**: Для хранения информации о пользователях, включая их роли, которые могут быть, например, администраторами, докладчиками или зрителями.
2. **Внешняя авторизация (`external_auths`)**: Содержит данные для связывания аккаунтов пользователей с их учетными записями во внешних сервисах авторизации, таких как VKID и YandexID, что позволяет пользователям использовать эти внешние учетные записи для входа в систему.
3. **Презентации (`presentations`)**: Для хранения информации о каждой презентации, включая ее автора, заголовок, описание, и статус.
4. **Слайды (`slides`)**: Содержит отдельные слайды для каждой презентации, включая информацию о типе слайда (информационный или интерактивный), порядке следования и содержимом.
5. **Вопросы (`questions`)**: Для интерактивных слайдов, содержит текст вопроса и правильный ответ. Связан с конкретными слайдами.
6. **Запуски презентаций (`presentation_runs`)**: Хранит информацию о каждом запуске презентации, включая время начала и окончания, а также статус (запущена, завершена).
7. **Просмотры слайдов (`slide_views`)**: Записывает, когда пользователь просматривает слайд во время запуска презентации, позволяя отслеживать взаимодействие.
8. **Запросы к ИИ (`ai_requests`)**: Хранит запросы пользователей к искусственному интеллекту для создания текста для интерактивных слайдов, включая текст запроса и ответ ИИ.

# Код с учетом принципов KISS, YAGNI, DRY и SOLID.
```
# main.py
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Optional

app = FastAPI()

class Presentation(BaseModel):
    id: Optional[int]
    title: str
    description: str
    user_id: int

presentations = []

@app.post("/presentations/")
def create_presentation(presentation: Presentation):
    presentation.id = len(presentations) + 1
    presentations.append(presentation)
    return presentation

@app.get("/presentations/", response_model=List[Presentation])
def list_presentations():
    return presentations

```

**Принципы, учтенные в серверном коде:**

- **KISS и YAGNI**: Сосредоточение на базовых операциях (создание и получение презентаций), без перегрузки функциональностью, которая на данном этапе не требуется.
- **DRY**: Использование Pydantic моделей для валидации и сериализации данных, избегая дублирования кода.
- **SOLID**: Специфические принципы SOLID в данном примере применить сложно из-за простоты задачи, но структура кода подготовлена для расширения в соответствии с этими принципами, например, добавление зависимостей и использование классов для более сложной бизнес-логики.

**Клиентский код на Vue.js:** 
```
<!-- App.vue -->
<template>
  <div id="app">
    <h1>Presentations</h1>
    <div v-for="presentation in presentations" :key="presentation.id">
      <h2>{{ presentation.title }}</h2>
      <p>{{ presentation.description }}</p>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      presentations: []
    };
  },
  mounted() {
    this.fetchPresentations();
  },
  methods: {
    async fetchPresentations() {
      const response = await fetch('/presentations/');
      const data = await response.json();
      this.presentations = data;
    }
  }
}
</script>

```

**Принципы, учтенные в клиентском коде:**
- **KISS и YAGNI**: Реализация простого интерфейса для отображения списка презентаций без сложных функций, которые могут не понадобиться на начальном этапе.
- **DRY**: Использование цикла `v-for` для отображения презентаций из массива, избегая дублирования разметки.
- **SOLID**: Как и в случае с серверным кодом, прямое применение принципов SOLID в простом Vue.js компоненте сложно, но структура компонента готова к дальнейшему разделению на более мелкие компоненты и использованию сервисов для работы с API.

# Дополнительные принципы разработки:

### BDUF (Big Design Up Front)

**Применимость:** Отказ. В контексте Agile и быстрой итеративной разработки, BDUF часто считается излишним, так как предполагает длительное и детальное планирование до начала разработки. Это может привести к потере гибкости и увеличению стоимости внесения изменений, особенно когда требования меняются в процессе работы.

### SoC (Separation of Concerns)

**Применимость:** Принято. Разделение ответственности важно для поддержки чистоты архитектуры и облегчения поддержки и расширения проекта. FastAPI и Vue.js, можно наблюдать разделение логики приложения: серверная часть управляет данными и API, в то время как клиентская часть отвечает за представление данных пользователю.

### MVP (Minimum Viable Product)

**Применимость:** Принято. Фокусировка на создании MVP позволяет быстро запустить продукт с минимальным набором функций, необходимым для сбора обратной связи от реальных пользователей. Это позволяет эффективно проверить гипотезы и определить направления дальнейшего развития продукта.

### PoC (Proof of Concept)

**Применимость:** Принято. Разработка PoC является важным шагом в проверке технических идей и подходов на практике, особенно когда внедряется новая технология или решение, которое не было ранее проверено в рамках проекта. PoC может быть использован для проверки возможности интеграции с внешними сервисами авторизации (VKID, YandexID).
